############################################################################
# This file is part of LImA, a Library for Image Acquisition
#
# Copyright (C) : 2009-2011
# European Synchrotron Radiation Facility
# BP 220, Grenoble 38043
# FRANCE
#
# This is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>.
############################################################################
#=============================================================================
#
# file :        LimaCCDs.py
#
# description : Python source for the LimaCCDs and its commands. 
#               The class is derived from Device. It represents the
#               CORBA servant object which will be accessed from the
#               network. All commands which can be executed on the
#               LimaCCDs are implemented in this file.
#
# project :    TANGO Device Server
#
# copyleft :    European Synchrotron Radiation Facility
#        BP 220, Grenoble 38043
#        FRANCE
#
#=============================================================================
#        This file is generated by seb
#
#      (c) - BLISS - ESRF
#=============================================================================
#

import sys,os,glob
import PyTango
import weakref
import itertools
import numpy

from Lima import Core

import plugins
import camera
try:
    import EdfFile
except ImportError:
    EdfFile = None
    
class LimaCCDs(PyTango.Device_4Impl) :

    Core.DEB_CLASS(Core.DebModApplication, 'LimaCCDs')
    _debugModuleList = ["None",
                        "Common",
                        "Hardware",
                        "HardwareSerial",
                        "Control",
                        "Espia",
                        "EspiaSerial",
                        "Focla",
                        "Camera",
                        "CameraCom",
                        "Test",
                        "Application"]
    
    _debugTypeList = ["Fatal",
                      "Error",
                      "Warning",
                      "Trace",
                      "Funct",
                      "Param",
                      "Return",
                      "Always"]
    
#------------------------------------------------------------------
#    Device constructor
#------------------------------------------------------------------
    def __init__(self,*args) :
        PyTango.Device_4Impl.__init__(self,*args)
        self.__className2deviceName = {}
        self.init_device()
        self.__lima_control = None

 	self.__key_header_delimiter = '='
        self.__entry_header_delimiter = '\n'
        self.__image_number_header_delimiter = ';'
       
#------------------------------------------------------------------
#    Device destructor
#------------------------------------------------------------------
    @Core.DEB_MEMBER_FUNCT
    def delete_device(self) :
        try:
            m = __import__('camera.%s' % (self.LimaCameraType),None,None,'camera.%s' % (self.LimaCameraType))
        except ImportError:
            pass
        else:
            m.close_interface()

#------------------------------------------------------------------
#    Device initialization
#------------------------------------------------------------------
    @Core.DEB_MEMBER_FUNCT
    def init_device(self) :
        self.set_state(PyTango.DevState.ON)
        self.get_device_properties(self.get_device_class())
        self.__className2deviceName = get_sub_devices()
        dataBase = PyTango.Database()

        try:
            m = __import__('camera.%s' % (self.LimaCameraType),None,None,'camera.%s' % (self.LimaCameraType))
        except ImportError:
            import traceback
            traceback.print_exc()
            self.set_state(PyTango.DevState.FAULT)
        else:
            properties = {}
            try:
                specificClass,specificDevice = m.get_tango_specific_class_n_device()
            except AttributeError: pass
            else:
		Core.DebParams.setTypeFlags(0)
                util = PyTango.Util.instance()
#                if specificClass and specificDevice:
#                    util.create_device(specificClass,specificDevice)
                #get properties for this device

                deviceName = self.__className2deviceName.get(specificDevice.__name__,None)
                if deviceName:
                    propertiesNames = dataBase.get_device_property_list(deviceName,"*")
                    for pName in propertiesNames.value_string:
                        key,value = dataBase.get_device_property(deviceName,pName).popitem()
                        if len(value) == 1:
                            value = value[0]
                        properties[key] = value
            
            self.__control = m.get_control(**properties)
            _set_control_ref(weakref.ref(self.__control))

        try:
            nb_thread = int(self.NbProcessingThread)
        except ValueError:
            pass
        else:
            Core.Processlib.PoolThreadMgr.get().setNumberOfThread(nb_thread)

        self.__accThresholdCallback = None
        try:
            accThresholdCallbackModule = self.AccThresholdCallbackModule
        except ValueError:
            pass
        else:
            try:
                m = __import__('plugins.%s' % (accThresholdCallbackModule),None,None,
                               'plugins.%s' % (accThresholdCallbackModule))
            except ImportError:
                deb.Error("Couldn't import plugins.%s" % accThresholdCallbackModule)
            else:
                try:
                    func = getattr(m,'get_acc_threshold_callback')
                    self.__accThresholdCallback = func()
                    acc = self.__control.accumulation()
                    acc.registerThresholdCallback(self.__accThresholdCallback)
                except AttributeError:
                    deb.Error("Accumulation threshold plugins module don't have get_acc_threshold_callback function")

        #Tango Enum to Lima Enum
        self.__Prefix2SubClass = {'acc' : self.__control.acquisition,
                                  'acq' : self.__control.acquisition,
                                  'shutter' : self.__control.shutter,
                                  'saving' : self.__control.saving}

        self.__Attribute2FunctionBase = {'acq_trigger_mode':'TriggerMode',
                                         'saving_overwrite_policy' : 'OverwritePolicy',
                                         'saving_format' : 'Format',
                                         'shutter_mode' : 'Mode'}
            
        self.__ShutterMode = {'MANUAL': Core.ShutterManual,
                              'AUTO_FRAME': Core.ShutterAutoFrame,
                              'AUTO_SEQUENCE': Core.ShutterAutoSequence}
        
        self.__AcqMode = {'SINGLE': Core.Single,
                          'CONCATENATION': Core.Concatenation,
                          'ACCUMULATION': Core.Accumulation}

        try:
            self.__AccTimeMode = {'LIVE' : Core.CtAcquisition.Live,
                                  'REAL' : Core.CtAcquisition.Real}
        except AttributeError:          # Core too Old
            self.__AccTimeMode = {}
        
        self.__SavingFormat = {'RAW' : Core.CtSaving.RAW,
                               'EDF' : Core.CtSaving.EDF,
                               'CBF' : Core.CtSaving.CBFFormat}

        self.__SavingFormatDefaultSuffix = {Core.CtSaving.RAW : '.raw',
                                            Core.CtSaving.EDF : '.edf',
                                            Core.CtSaving.CBFFormat : '.cbf'}

        self.__SavingMode = {'MANUAL' : Core.CtSaving.Manual,
                             'AUTO_FRAME' : Core.CtSaving.AutoFrame,
                             'AUTO_HEADER' : Core.CtSaving.AutoHeader}

        self.__SavingOverwritePolicy = {'ABORT' : Core.CtSaving.Abort,
                                        'OVERWRITE' : Core.CtSaving.Overwrite,
                                        'APPEND' : Core.CtSaving.Append}

        self.__AcqTriggerMode = {'INTERNAL_TRIGGER' : Core.IntTrig,
                                 'EXTERNAL_TRIGGER' : Core.ExtTrigSingle,
                                 'EXTERNAL_TRIGGER_MULTI' : Core.ExtTrigMult,
                                 'EXTERNAL_GATE' : Core.ExtGate,
                                 'EXTERNAL_START_STOP' : Core.ExtStartStop}
	try:
	    self.__AcqTriggerMode['INTERNAL_TRIGGER_MULTI'] = Core.IntTrigMult
	except AttributeError:
	    pass


        
    def __getattr__(self,name) :
        if name.startswith('is_') and name.endswith('_allowed') :
            split_name = name.split('_')[1:-1]
            attr_name = ''.join([x.title() for x in split_name])
            dict_name = '_' + self.__class__.__name__ + '__' + attr_name
            d = getattr(self,dict_name,None)
            func = _allowed
            if d is not None:
                if not d:
                    func = _not_allowed
            self.__dict__[name] = func
            return func
        elif name.startswith('read_') or name.startswith('write_') :
            split_name = name.split('_')[1:]
            attr_name = ''.join([x.title() for x in split_name])
            dict_name = '_' + self.__class__.__name__ + '__' + attr_name
            d = getattr(self,dict_name,None)
            getObjectFunc = self.__Prefix2SubClass.get(split_name[0],None)
            attr_name = self.__Attribute2FunctionBase.get('_'.join(split_name),attr_name)
            if d and getObjectFunc:
                obj = getObjectFunc()
                if name.startswith('read_') :
                    functionName = 'get' + attr_name
                    function2Call = getattr(obj,functionName)
                    callable_obj = CallableReadEnum(d,function2Call)
                else:
                    functionName = 'set' + attr_name
                    function2Call = getattr(obj,functionName)
                    callable_obj = CallableWriteEnum('_'.join(split_name),
                                                     d,function2Call)
                self.__dict__[name] = callable_obj
                return callable_obj
        
        raise AttributeError('LimaCCDs has no attribute %s' % name)


#==================================================================
#
#    LimaCCDs read/write attribute methods
#
#==================================================================

    ## @brief Read the Lima Type
    #
    @Core.DEB_MEMBER_FUNCT
    def read_lima_type(self,attr) :        
        value  = self.LimaCameraType	
        attr.set_value(value)

    ## @brief Read the Camera Type
    #
    @Core.DEB_MEMBER_FUNCT
    def read_camera_type(self,attr) :        
        interface = self.__control.hwInterface()
	det_info = interface.getHwCtrlObj(Core.HwCap.DetInfo)
	value = det_info.getDetectorType()
        attr.set_value(value)

    ## @brief Read the Camera Model
    #
    @Core.DEB_MEMBER_FUNCT
    def read_camera_model(self,attr) :        
	interface = self.__control.hwInterface()
	det_info = interface.getHwCtrlObj(Core.HwCap.DetInfo)
	value = det_info.getDetectorModel() 
	attr.set_value(value)
        
    ## @brief get the status of the acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acq_status(self,attr) :
        status = self.__control.getStatus()
        state2string = {Core.AcqReady : "Ready",
                        Core.AcqRunning : "Running",
                        Core.AcqFault : "Fault"}
        attr.set_value(state2string.get(status.AcquisitionStatus,"?"))

    ## @brief read the number of frame for an acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acq_nb_frames(self,attr) :
        acquisition = self.__control.acquisition()
        nb_frames = acquisition.getAcqNbFrames()
        attr.set_value(nb_frames)

    ## @brief write the number of frame for an acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def write_acq_nb_frames(self,attr) :
        data = []
        attr.get_write_value(data)
        acquisition = self.__control.acquisition()
        acquisition.setAcqNbFrames(data[0])
        
    ## @brief read the number of frame for an acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acq_expo_time(self,attr) :
        acquisition = self.__control.acquisition()
        expo_time = acquisition.getAcqExpoTime()
        attr.set_value(expo_time)

    ## @brief write the number of frame for an acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def write_acq_expo_time(self,attr) :
        data = []
        attr.get_write_value(data)
        acquisition = self.__control.acquisition()
        acquisition.setAcqExpoTime(data[0])
        
    ## @brief Read maximum accumulation exposure time
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acc_max_expo_time(self,attr) :        
	acq = self.__control.acquisition()

        value = acq.getAccMaxExpoTime()
	if value is None: value = -1
	
        attr.set_value(value)

    ## @brief Write the accumulation max exposure time
    #
    @Core.DEB_MEMBER_FUNCT
    def write_acc_max_expo_time(self,attr) :
        data = []
        attr.get_write_value(data)
	acq = self.__control.acquisition()
        acq.setAccMaxExpoTime(*data)

    ## @brief Read maximum accumulation exposure time
    #
    @Core.DEB_MEMBER_FUNCT
    def read_concat_nb_frames(self,attr) :        
	acq = self.__control.acquisition()
        value = acq.getConcatNbFrames()
        attr.set_value(value)

    ## @brief Write the accumulation max exposure time
    #
    @Core.DEB_MEMBER_FUNCT
    def write_concat_nb_frames(self,attr) :
        data = []
        attr.get_write_value(data)
	acq = self.__control.acquisition()
        acq.setConcatNbFrames(*data)

    ## @brief Read calculated accumulation exposure time
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acc_expo_time(self,attr) :        
	acq = self.__control.acquisition()

        value = acq.getAccExpoTime()
	if value is None: value = -1
	
        attr.set_value(value)
	
    ## @brief Read calculated accumulation number of frames
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acc_nb_frames(self,attr) :        
	acq = self.__control.acquisition()
        value = acq.getAccNbFrames()
	if value is None: value = -1
	
        attr.set_value(value)

    ## @brief Read calculated accumulation dead time
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acc_dead_time(self,attr) :        
	acq = self.__control.acquisition()
        value = acq.getAccDeadTime()

        attr.set_value(value)

    ## @brief Read calculated accumulation live time
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acc_live_time(self,attr) :        
	acq = self.__control.acquisition()
        value = acq.getAccLiveTime()
	
        attr.set_value(value)

    ## @brief Read if saturated calculation is active
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acc_saturated_active(self,attr) :        
	acc = self.__control.accumulation()
        value = acc.getActive()
	
        attr.set_value(value)

    ## @brief active/unactive calculation of saturated images and counters
    #
    @Core.DEB_MEMBER_FUNCT
    def write_acc_saturated_active(self,attr) :        
        data = []
        attr.get_write_value(data)

	acc = self.__control.accumulation()
        acc.setActive(data[0])

    ## @brief Read saturated threshold
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acc_saturated_threshold(self,attr) :        
	acc = self.__control.accumulation()
        value = acc.getPixelThresholdValue()
	
        attr.set_value(value)

    ## @brief Set saturated threshold
    #
    @Core.DEB_MEMBER_FUNCT
    def write_acc_saturated_threshold(self,attr) :        
        data = []
        attr.get_write_value(data)

	acc = self.__control.accumulation()
        acc.setPixelThresholdValue(data[0])

    ## @brief Read if saturated calculation is active
    #
    @Core.DEB_MEMBER_FUNCT
    def read_acc_saturated_cblevel(self,attr) :
        if self.__accThresholdCallback is not None:
            attr.set_value(self.__accThresholdCallback.m_max)
        else:
            msg = "Accumulation threshold plugins not loaded"
            deb.Error(msg)
            raise Exception, msg

    ## @brief active/unactive calculation of saturated images and counters
    #
    @Core.DEB_MEMBER_FUNCT
    def write_acc_saturated_cblevel(self,attr) :        
        data = []
        attr.get_write_value(data)
        if self.__accThresholdCallback is not None:
            self.__accThresholdCallback.m_max = data[0]
        else:
            msg = "Accumulation threshold plugins not loaded"
            deb.Error(msg)
            raise Exception, msg
        
    ## @brief Read latency time 
    #
    @Core.DEB_MEMBER_FUNCT
    def read_latency_time(self,attr) :
        acq = self.__control.acquisition()

        value = acq.getLatencyTime()
        if value is None: value = -1

        attr.set_value(value)

    ## @brief Write Latency time 
    #
    @Core.DEB_MEMBER_FUNCT
    def write_latency_time(self,attr) :
        data = []
        attr.get_write_value(data)
        acq = self.__control.acquisition()

        acq.setLatencyTime(*data)

    ## @brief Read image Roi
    #
    @Core.DEB_MEMBER_FUNCT
    def read_image_roi(self,attr) :
        image = self.__control.image()
        roi = image.getRoi()
        point = roi.getTopLeft()
        size = roi.getSize()
        
        attr.set_value([point.x,point.y,
                        size.getWidth(),size.getHeight()])

    ## @brief Write image Roi
    #
    @Core.DEB_MEMBER_FUNCT
    def write_image_roi(self,attr) :
        data = []
        attr.get_write_value(data)
        image = self.__control.image()
        roi = Core.Roi(*data)
        image.setRoi(roi)

    ## @brief Read image type
    #
    @Core.DEB_MEMBER_FUNCT
    def read_image_sizes(self,attr) :
        imageType2NbBytes = {
            Core.Bpp8 : 1 ,
            Core.Bpp8S : 1 ,
            Core.Bpp10 : 2 ,
            Core.Bpp10S : 2 ,
            Core.Bpp12 : 2 ,
            Core.Bpp12S : 2 ,
            Core.Bpp14 : 2 ,
            Core.Bpp14S : 2 , 
            Core.Bpp16 : 2,
            Core.Bpp16S : 2,
            Core.Bpp32 : 4 ,
            Core.Bpp32S : 4
            }        
        image = self.__control.image()
        imageType = image.getImageType()
        dim = image.getImageDim()
        
        sizes = [imageType2NbBytes.get(imageType,"?"), dim.getSize().getWidth(), dim.getSize().getHeight()]
        
        attr.set_value(sizes)

    ## @brief Read image type
    #
    @Core.DEB_MEMBER_FUNCT
    def read_image_type(self,attr) :
        imageType2String = {
            Core.Bpp8 : "Bpp8" ,
            Core.Bpp8S : "Bpp8S" ,
            Core.Bpp10 : "Bpp10" ,
            Core.Bpp10S : "Bpp10S" ,
            Core.Bpp12 : "Bpp12" ,
            Core.Bpp12S : "Bpp12S" ,
            Core.Bpp14 : "Bpp14" ,
            Core.Bpp14S : "Bpp14S" , 
            Core.Bpp16 : "Bpp16" ,
            Core.Bpp16S : "Bpp16S" ,
            Core.Bpp32 : "Bpp32" ,
            Core.Bpp32S : "Bpp32S"
            }
        image = self.__control.image()
        imageType = image.getImageType()
        stringType = imageType2String.get(imageType,"?")
                
        attr.set_value(stringType)

    ## @brief Read image width
    #
    @Core.DEB_MEMBER_FUNCT
    def read_image_width(self,attr) :
        image = self.__control.image()
 	dim = image.getImageDim()
                        
        attr.set_value(dim.getSize().getWidth())

    ## @brief Read image height
    #
    @Core.DEB_MEMBER_FUNCT
    def read_image_height(self,attr) :
        image = self.__control.image()
 	dim = image.getImageDim()
                        
        attr.set_value(dim.getSize().getHeight())

    ## @brief Read image binning
    #
    @Core.DEB_MEMBER_FUNCT
    def read_image_bin(self,attr) :
        image = self.__control.image()
        binValues = image.getBin()
                        
        attr.set_value([binValues.getX(),
                        binValues.getY()],2)

    ## @brief Write image binning
    #
    @Core.DEB_MEMBER_FUNCT
    def write_image_bin(self,attr) :
        data = []
        attr.get_write_value(data)

        image = self.__control.image()
        binValue = Core.Bin(*data)
        image.setBin(binValue)
    

    ## @brief Read image flip
    #
    @Core.DEB_MEMBER_FUNCT
    def read_image_flip(self,attr) :
        image = self.__control.image()
        flip = image.getFlip()
        attr.set_value([flip.x,flip.y],2)

    ## @brief Write image flip
    #
    @Core.DEB_MEMBER_FUNCT
    def write_image_flip(self,attr) :
        data = []
        attr.get_write_value(data)
        flip = Core.Flip(*data)
        image = self.__control.image()
        image.setFlip(flip)

    ## @brief Read image flip
    #
    @Core.DEB_MEMBER_FUNCT
    def read_saving_common_header(self,attr) :
        saving = self.__control.saving()
        header = saving.getCommonHeader()
        headerArr = ['%s%s%s' % (k,self.__key_header_delimiter,v) for k,v in header.iteritems()]
        attr.set_value(headerArr,len(headerArr))

    ## @brief Write image flip
    #
    @Core.DEB_MEMBER_FUNCT
    def write_saving_common_header(self,attr) :
        data = []
        attr.get_write_value(data)
        header = dict([x.split(self.__key_header_delimiter) for x in data])
        saving = self.__control.saving()
        saving.setCommonHeader(header)

    ## @brief Read header delimiter
    #
    @Core.DEB_MEMBER_FUNCT
    def read_saving_header_delimiter(self,attr) :
        attr.set_value([self.__key_header_delimiter,
                        self.__entry_header_delimiter,
                        self.__image_number_header_delimiter],3)

    ##@brief Write header delimiter
    #
    def write_saving_header_delimiter(self,attr) :
        data = []
        attr.get_write_value(data)
        self.__key_header_delimiter = data[0]
        self.__entry_header_delimiter = data[1]
        self.__image_number_header_delimiter = data[2]
    
    ## @brief Read last image acquired
    #
    @Core.DEB_MEMBER_FUNCT
    def read_last_image_ready(self,attr) :
        status = self.__control.getStatus()
	img_counters= status.ImageCounters

        value = img_counters.LastImageReady
        if value is None: value = -1

        attr.set_value(value)

    ## @brief Read last image saved
    #
    @Core.DEB_MEMBER_FUNCT
    def read_last_image_saved(self,attr) :
        status = self.__control.getStatus()
        img_counters= status.ImageCounters

        value = img_counters.LastImageSaved
        if value is None: value = -1

        attr.set_value(value)

    ## @brief this flag is true just after
    #  the detector readout.
    #
    # This attribute should be use
    #  to test is client can re-trigger an other image
    @Core.DEB_MEMBER_FUNCT
    def read_ready_for_next_image(self,attr) :
        interface = self.__control.hwInterface()
        status = interface.getStatus()
        attr.set_value(status.det == Core.DetIdle)

    ## @brief this flag is true when acquisition is finished
    #
    @Core.DEB_MEMBER_FUNCT
    def read_ready_for_next_acq(self,attr) :
        status = self.__control.getStatus()
        attr.set_value(status.AcquisitionStatus == Core.AcqReady)

    
    ## @brief read write statistic
    #
    @Core.DEB_MEMBER_FUNCT
    def read_write_statistic(self,attr) :
        saving = self.__control.saving()
        stat = saving.getWriteTimeStatistic()
        if not len(stat) :
            attr.set_value([-1],1)
        else:
            attr.set_value(stat,len(stat))
	

    ## @brief Read current shutter state 
    # True-Open, False-Close
    @Core.DEB_MEMBER_FUNCT
    def read_shutter_manual_state(self,attr) :
        shutter = self.__control.shutter()

	if shutter.hasCapability() and shutter.getModeList().count(Core.ShutterManual):
            if shutter.getState(): state = "OPEN"
            else: state = "CLOSED"
	else:
            state = "NO_MANUAL_MODE"
			
        attr.set_value(value)


    ## @brief Read shutter open time
    # True-Open, False-Close
    @Core.DEB_MEMBER_FUNCT
    def read_shutter_open_time(self,attr) :
        shutter = self.__control.shutter()

        value = shutter.getOpenTime()
        if value is None: value = -1

        attr.set_value(value)

    ## @brief Write shutter open time 
    # 
    @Core.DEB_MEMBER_FUNCT
    def write_shutter_open_time(self,attr) :
        data = []
        attr.get_write_value(data)
        shutter = self.__control.shutter()

        shutter.setOpenTime(*data)

    ## @brief Read shutter close time
    # in seconds
    @Core.DEB_MEMBER_FUNCT
    def read_shutter_close_time(self,attr) :
        shutter = self.__control.shutter()

        value = shutter.getCloseTime()
        if value is None: value = -1

        attr.set_value(value)

    ## @brief Write shutter close time 
    # in seconds
    @Core.DEB_MEMBER_FUNCT
    def write_shutter_close_time(self,attr) :
        data = []
        attr.get_write_value(data)
        shutter = self.__control.shutter()
        
        shutter.setCloseTime(*data)

    @Core.DEB_MEMBER_FUNCT
    def read_saving_directory(self,attr) :
        saving = self.__control.saving()

        attr.set_value(saving.getDirectory())

    @Core.DEB_MEMBER_FUNCT
    def write_saving_directory(self,attr) :
        data = []
        attr.get_write_value(data)
        saving = self.__control.saving()
        newDirectory = data[0]
        if os.access(newDirectory,os.W_OK|os.X_OK) :
            saving.setDirectory(newDirectory)
        else:
            PyTango.Except.throw_exception('Access Error',\
                                           'Directory %s is not writtable'%(newDirectory),\
                                           'LimaCCD Class')

    @Core.DEB_MEMBER_FUNCT
    def read_saving_prefix(self,attr) :
        saving = self.__control.saving()

        attr.set_value(saving.getPrefix())

    @Core.DEB_MEMBER_FUNCT
    def write_saving_prefix(self,attr) :
        data = []
        attr.get_write_value(data)
        saving = self.__control.saving()
        prefix = data[0]

        directory = saving.getDirectory()
        suffix = saving.getSuffix()
        overwritePolicy = saving.getOverwritePolicy()
        if overwritePolicy == Core.CtSaving.Abort:
            matchFiles = glob.glob(os.path.join(directory,'%s*%s' % (prefix,suffix)))
            lastnumber = _getLastFileNumber(prefix,suffix,matchFiles)
        else:
            lastnumber = -1
        saving.setPrefix(prefix)
        saving.setNextNumber(lastnumber + 1)

    @Core.DEB_MEMBER_FUNCT
    def read_saving_suffix(self,attr) :
        saving = self.__control.saving()

        attr.set_value(saving.getSuffix())

    @Core.DEB_MEMBER_FUNCT
    def write_saving_suffix(self,attr) :
        data = []
        attr.get_write_value(data)
        saving = self.__control.saving()

        saving.setSuffix(*data)

    @Core.DEB_MEMBER_FUNCT
    def read_saving_next_number(self,attr) :
        saving = self.__control.saving()

        attr.set_value(saving.getNextNumber())

    @Core.DEB_MEMBER_FUNCT
    def write_saving_next_number(self,attr) :
        data = []
        attr.get_write_value(data)
        saving = self.__control.saving()

        saving.setNextNumber(*data)

    @Core.DEB_MEMBER_FUNCT
    def read_saving_frame_per_file(self,attr) :
        saving = self.__control.saving()

        attr.set_value(saving.getFramePerFile())

    @Core.DEB_MEMBER_FUNCT
    def write_saving_frame_per_file(self,attr) :
        data = []
        attr.get_write_value(data)
        saving = self.__control.saving()

        saving.setFramesPerFile(*data)
        
    ## @brief Change the saving Format
    #
    @Core.DEB_MEMBER_FUNCT
    def write_saving_format(self,attr) :
        data = []
        attr.get_write_value(data)
        saving = self.__control.saving()

        value = _getDictValue(self.__SavingFormat,data[0].upper())
	if value is None:
            PyTango.Except.throw_exception('WrongData',\
                                           'Wrong value %s: %s'%('saving_format',data[0].upper()),\
                                           'LimaCCD Class')
        else:
            saving.setFormat(value)
            defaultSuffix = self.__SavingFormatDefaultSuffix.get(value,'.unknown')
            saving.setSuffix(defaultSuffix)

    ## @brief Read the frame per file
    #
    @Core.DEB_MEMBER_FUNCT
    def read_frame_per_file(self,attr) :
        saving = self.__control.saving()

        value = saving.getFramePerFile()
        attr.set_value(value)

    ## @brief Change the number of saving frame per file
    #
    @Core.DEB_MEMBER_FUNCT
    def write_frame_per_file(self,attr) :
        data = []
        attr.get_write_value(data)
        saving = self.__control.saving()

        saving.setFramesPerFile(data[0])

    ##@biref Read possible modules
    #
    def read_debug_modules_possible(self,attr) :
        attr.set_value(LimaCCDs._debugModuleList,len(LimaCCDs._debugModuleList))
        
    ##@brief Read list of module which are in debug
    #
    @Core.DEB_MEMBER_FUNCT
    def read_debug_modules(self,attr) :
        NameList = Core.DebParams.getModuleFlagsNameList()
        attr.set_value(NameList,len(NameList))

    ##@brief set debug module list
    #
    @Core.DEB_MEMBER_FUNCT
    def write_debug_modules(self,attr) :
        data = []
        attr.get_write_value(data)
        Core.DebParams.setModuleFlagsNameList(data)
    
    ##@biref Read possible modules
    #
    def read_debug_types_possible(self,attr) :
        attr.set_value(LimaCCDs._debugTypeList,len(LimaCCDs._debugTypeList))
        
    ##@brief Read list of module which are in debug
    #
    @Core.DEB_MEMBER_FUNCT
    def read_debug_types(self,attr) :
        NameList = Core.DebParams.getTypeFlagsNameList()

        if NameList:
            attr.set_value(NameList,len(NameList))
        else:
            attr.set_value([''],1)

    ##@brief set debug module list
    #
    @Core.DEB_MEMBER_FUNCT
    def write_debug_types(self,attr) :
        data = []
        attr.get_write_value(data)
        Core.DebParams.setTypeFlagsNameList(data)
    
#==================================================================
#
#    LimaCCDs command methods
#
#==================================================================
#------------------------------------------------------------------
#    getAttrStringValueList command:
#
#    Description: return a list of authorized values if any
#    argout: DevVarStringArray   
#------------------------------------------------------------------
    @Core.DEB_MEMBER_FUNCT
    def getAttrStringValueList(self, attr_name):
        valueList=[]
        if attr_name == 'shutter_mode':
            shutter = self.__control.shutter()
            if shutter.hasCapability():
                #Depending of the camera only a subset of the mode list can be supported
                values = shutter.getModeList()
                valueList = [_getDictKey(self.__ShutterMode,val) for val in values]
        else:
            dict_name = '_' + self.__class__.__name__ + '__' + ''.join([x.title() for x in attr_name.split('_')])
            d = getattr(self,dict_name,None)
            if d:
                valueList = d.keys()

        return valueList

    ##@brief prepare an acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def prepareAcq(self) :
        self.__control.prepareAcq()

    ##@brief start an acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def startAcq(self) :
        self.__control.startAcq()

    ##@brief stop an acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def stopAcq(self) :
        self.__control.stopAcq()

    ##@brief reset acquisition
    #
    @Core.DEB_MEMBER_FUNCT
    def reset(self) :
        self.__control.reset()

    ##@brief set images heaaders
    #
    @Core.DEB_MEMBER_FUNCT
    def setImageHeader(self,headers_str) :
        control = self.__control
        saving = control.saving()
        for image_header in headers_str:
            imageIdSepPos = image_header.find(self.__image_number_header_delimiter)
            imageId = int(image_header[:imageIdSepPos])
            header_str = image_header[imageIdSepPos+1:]
            deb.Param('Setting to image %d file header: %s' % (imageId,header_str))
            header_map = {}
            for line in header_str.split(self.__entry_header_delimiter) :
                token = line.split(self.__key_header_delimiter)
                key = token[0].strip()
                if not key:
                    continue
                try:
                    val = '='.join(token[1:]).strip()
                except ValueError:
                    continue
                if val.endswith(';'):
                    val = val[:-1]
                header_map[key] = val
            saving.updateFrameHeader(imageId,header_map)

    ##@brief get image data
    #
    @Core.DEB_MEMBER_FUNCT
    def getImage(self,image_id) :
        self._data_cache = self.__control.ReadImage(image_id)
        dataflat = self._data_cache.buffer.ravel()
        dataflat.dtype = numpy.uint8
        return dataflat

    ##@brief get base image data
    #
    #image before post processing
    @Core.DEB_MEMBER_FUNCT
    def getBaseImage(self,image_id) :
        self._data_cache = self.__control.ReadBaseImage(image_id)
        dataflat = self._data_cache.buffer.ravel()
        dataflat.dtype = numpy.uint8
        return dataflat

    ##@brief get saturated images
    #
    #@params image_id if < 0 read the last image
    @Core.DEB_MEMBER_FUNCT
    def readAccSaturatedImageCounter(self,image_id) :
        acc = self.__control.accumulation()
        self._saturated_image_cache = acc.readSaturatedImageCounter(image_id)
        arr = self._saturated_image_cache.buffer
        if arr is None: arr = []
        else: arr = arr.ravel()
        return arr

    ##@brief get saturated sum counter
    #
    #@params from_image_id the starting image id
    @Core.DEB_MEMBER_FUNCT
    def readAccSaturatedSumCounter(self,from_image_id) :
        acc = self.__control.accumulation()
        sumCounters = acc.readSaturatedSumCounter(from_image_id)
        returnList = []
        if sumCounters:
            number_of_counters_per_image = len(sumCounters[0])
            returnList = list(itertools.chain(*sumCounters))
            returnList.insert(0,number_of_counters_per_image)
        return returnList
    ##@brief set the mask file for saturated counters
    #
    #@params file_path the full path of mask image or '' -> unset Mask
    @Core.DEB_MEMBER_FUNCT
    def setAccSaturatedMask(self,file_path) :
        if file_path:
            f = EdfFile.EdfFile(file_path)
            d = f.GetData(0)
            data = Core.Processlib.Data()
            data.buffer = d
        else:                           # UNSET MASK
            data = Core.Processlib.Data()
        acc = self.__control.accumulation()
        acc.setMask(data)
            
#------------------------------------------------------------------
#    closeShutterManual command:
#
#    Description: Close the shutter manual
#    argout: DevVoid  
#------------------------------------------------------------------
    @Core.DEB_MEMBER_FUNCT
    def closeShutterManual(self):

        shutter = self.__control.shutter()
        
	if shutter.hasCapability() and shutter.getModeList().count(Core.ShutterManual):
            shutter.setState(False)
            
#------------------------------------------------------------------
#    openShutterManual command:
#
#    Description: Open the shutter manual
#    argout: DevVoid  
#------------------------------------------------------------------
    @Core.DEB_MEMBER_FUNCT
    def openShutterManual(self):

        shutter = self.__control.shutter()
        
	if shutter.hasCapability() and shutter.getModeList().count(Core.ShutterManual):
            shutter.setState(True)





#==================================================================
#
#    LimaTacoCCDsClass class definition
#
#==================================================================
class LimaCCDsClass(PyTango.DeviceClass) :
    #    Class Properties
    class_property_list = {
        }


    #    Device Properties
    device_property_list = {
        'LimaCameraType' :
        [PyTango.DevString,
         "Camera Plugin name",[]],
        'NbProcessingThread' :
        [PyTango.DevString,
         "Number of thread for processing",[2]],
        'AccThresholdCallbackModule':
        [PyTango.DevString,
         "Plugin name file which manage threshold",[]],
        }

    #    Command definitions
    cmd_list = {
        'openShutterManual':
        [[PyTango.DevVoid, ""],
         [PyTango.DevVoid, ""]],
        'closeShutterManual':
        [[PyTango.DevVoid, ""],
         [PyTango.DevVoid, ""]],
        'getAttrStringValueList':
        [[PyTango.DevString, "Attribute name"],
         [PyTango.DevVarStringArray, "Authorized String value list"]],
        'prepareAcq':
        [[PyTango.DevVoid,""],
         [PyTango.DevVoid,""]],
        'startAcq':
        [[PyTango.DevVoid,""],
         [PyTango.DevVoid,""]],
        'stopAcq':
        [[PyTango.DevVoid,""],
         [PyTango.DevVoid,""]],
        'reset':
        [[PyTango.DevVoid,""],
         [PyTango.DevVoid,""]],
        'setImageHeader':
        [[PyTango.DevVarStringArray,"ImageId0 SEPARATOR imageHeader0,ImageId1 SEPARATOR imageHeader1..."],
         [PyTango.DevVoid,""]],
        'getImage':
        [[PyTango.DevLong,"The image number"],
         [PyTango.DevVarCharArray,"The data image"]],
        'getBaseImage':
        [[PyTango.DevLong,"The image number"],
         [PyTango.DevVarCharArray,"The base data image"]],
        'readAccSaturatedImageCounter':
        [[PyTango.DevLong,"The image number"],
         [PyTango.DevVarUShortArray,"The image counter"]],
        'readAccSaturatedSumCounter':
        [[PyTango.DevLong,"From image id"],
         [PyTango.DevVarLongArray,"number of result for each images,sum counter of raw image #0 of image #0,sum counter of raw image #1 of image #0,..."]],
        'setAccSaturatedMask':
         [[PyTango.DevVarStringArray,"Full path of mask file"],
         [PyTango.DevVoid,""]],
	}
    
    #    Attribute definitions
    attr_list = {
        'lima_type':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ]],
        'camera_type':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ]],	 
        'camera_model':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ]],
        'acq_status':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ]],
        'acc_expo_time':
        [[PyTango.DevDouble,
          PyTango.SCALAR,
          PyTango.READ]],	      	
        'acc_nb_frames':
        [[PyTango.DevLong,
          PyTango.SCALAR,
          PyTango.READ]],	      	
        'acc_dead_time':
        [[PyTango.DevDouble,
          PyTango.SCALAR,
          PyTango.READ]],	      	
        'acc_live_time':
        [[PyTango.DevDouble,
          PyTango.SCALAR,
          PyTango.READ]],	      	
        'acc_saturated_active':
        [[PyTango.DevBoolean,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'acc_saturated_threshold':
        [[PyTango.DevLong,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'acc_saturated_cblevel':
        [[PyTango.DevLong,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'acq_mode':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'acc_time_mode':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'acq_nb_frames':
        [[PyTango.DevLong,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'acq_expo_time':
        [[PyTango.DevDouble,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'acc_max_expo_time':
        [[PyTango.DevDouble,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'concat_nb_frames':
        [[PyTango.DevLong,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'latency_time':
        [[PyTango.DevDouble,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],	      	
        'acq_trigger_mode':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'image_roi':
        [[PyTango.DevLong,
          PyTango.SPECTRUM,
          PyTango.READ_WRITE,4]],
        'image_sizes':
        [[PyTango.DevULong,
          PyTango.SPECTRUM,
          PyTango.READ,3],
         {
             'label':"Image sizes:Depth, Width, Height",
             'unit':"",
             'standard unit':"",
             'display unit':"",
             'format':"%d",
             'description':"nb bytes of depth, nb pixels of width and nb pixels of height",
         }],
        'image_type':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ]],
        'image_width':
        [[PyTango.DevULong,
          PyTango.SCALAR,
          PyTango.READ]],
        'image_height':
        [[PyTango.DevULong,
          PyTango.SCALAR,
          PyTango.READ]],
        'image_bin':
        [[PyTango.DevULong,
          PyTango.SPECTRUM,
          PyTango.READ_WRITE,2]],
        'image_flip':
        [[PyTango.DevBoolean,
          PyTango.SPECTRUM,
          PyTango.READ_WRITE,2]],
        'last_image_ready':
        [[PyTango.DevLong,
          PyTango.SCALAR,
          PyTango.READ]],
        'last_image_saved':
        [[PyTango.DevLong,
          PyTango.SCALAR,
          PyTango.READ]],
        'ready_for_next_image':
        [[PyTango.DevBoolean,
          PyTango.SCALAR,
          PyTango.READ]],
        'ready_for_next_acq':
        [[PyTango.DevBoolean,
          PyTango.SCALAR,
          PyTango.READ]],
        'write_statistic':
        [[PyTango.DevDouble,
          PyTango.SPECTRUM,
          PyTango.READ,256]],
        'shutter_mode':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'shutter_open_time':
        [[PyTango.DevDouble,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'shutter_close_time':
        [[PyTango.DevDouble,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'saving_directory':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'saving_prefix':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'saving_suffix':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'saving_next_number':
        [[PyTango.DevLong,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'saving_format':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'saving_mode':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'saving_overwrite_policy':
        [[PyTango.DevString,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'saving_frame_per_file':
        [[PyTango.DevLong,
          PyTango.SCALAR,
          PyTango.READ_WRITE]],
        'saving_common_header':
        [[PyTango.DevString,
          PyTango.SPECTRUM,
          PyTango.READ_WRITE,65535]],
        'saving_header_delimiter':
        [[PyTango.DevString,
          PyTango.SPECTRUM,
          PyTango.READ_WRITE,3]],
        'debug_modules_possible':
         [[PyTango.DevString,
          PyTango.SPECTRUM,
          PyTango.READ,len(LimaCCDs._debugModuleList)]],
        'debug_modules':
        [[PyTango.DevString,
          PyTango.SPECTRUM,
          PyTango.READ_WRITE,len(LimaCCDs._debugModuleList)]],
        'debug_types_possible':
         [[PyTango.DevString,
          PyTango.SPECTRUM,
          PyTango.READ,len(LimaCCDs._debugTypeList)]],
        'debug_types':
        [[PyTango.DevString,
          PyTango.SPECTRUM,
          PyTango.READ_WRITE,len(LimaCCDs._debugTypeList)]],
        }

def declare_camera_n_commun_to_tango_world(util) :
    for module_name in camera.__all__:
        try:
            m = __import__('camera.%s' % (module_name),None,None,'camera.%s' % (module_name))
        except ImportError:
            continue
        else:
            try:
		func = getattr(m,'get_tango_specific_class_n_device')
                specificClass,specificDevice = func()
            except AttributeError:
                continue
            else:
                util.add_TgClass(specificClass,specificDevice,specificDevice.__name__)

    for module_name in plugins.__all__:
        try:
            m = __import__('plugins.%s' % (module_name),None,None,'plugins.%s' % (module_name))
        except ImportError:
	    import traceback
	    traceback.print_exc()
            continue
        else:
            try:
		func = getattr(m,'get_tango_specific_class_n_device')
            except AttributeError:
                continue
            else:
                specificClass,specificDevice = func()
		util.add_TgClass(specificClass,specificDevice,specificDevice.__name__)

def export_default_plugins() :
    #Post processing tango export
    util = PyTango.Util.instance()
    className2deviceName = get_sub_devices()
    masterDeviceName = className2deviceName.get('LimaCCDs',None)
    if masterDeviceName:
        beamlineName,_,cameraName = masterDeviceName.split('/')
        for module_name in plugins.__all__:
            try:
                m = __import__('plugins.%s' % (module_name),None,None,'plugins.%s' % (module_name))
            except ImportError:
                continue
            else:
                try:
                    specificClass,specificDevice = m.get_tango_specific_class_n_device()
                except AttributeError:
                    continue

                deviceName = className2deviceName.get(specificDevice.__name__,None)
                #only create one if not exist
                if deviceName is None and specificClass and specificDevice:
                    deviceName = '%s/%s/%s' % (beamlineName,
                                               specificDevice.__name__.lower().replace('deviceserver',''),cameraName)
                    print 'create device',specificDevice.__name__,deviceName
                    try:
                        util.create_device(specificDevice.__name__,deviceName)
                    except:
                        import traceback
                        traceback.print_exc()

def _set_control_ref(ctrl_ref) :
    for module_name in plugins.__all__:
        try:
            m = __import__('plugins.%s' % (module_name),None,None,'plugins.%s' % (module_name))
        except ImportError:
            continue
	else:
	    try:
	        func = getattr(m,"set_control_ref")
		func(ctrl_ref)
	    except AttributeError:
		continue

#============================================================================
#                                TOOLS
#============================================================================
def _getLastFileNumber(prefix,suffix,filesPath) :
    lastNumber = -1
    prefixLen = len(prefix)
    lenSuffix = len(suffix)

    for fPath in filesPath :
        fName = os.path.split(fPath)[-1]
        number = fName[prefixLen:-lenSuffix]
        try:
            number = int(number)
        except ValueError:
            continue
        else:
            if number > lastNumber:
                lastNumber = number
    return lastNumber

def _getDictKey(dict, value):
    try:
        ind = dict.values().index(value)                            
    except ValueError:
        return None
    return dict.keys()[ind]

def _getDictValue(dict, key):
    try:
        value = dict[key.upper()]
    except KeyError:
        return None
    return value

def _allowed(*args) :
    return True

def _not_allowed(*args) :
    return False

def get_sub_devices() :
    className2deviceName = {}
    #get sub devices
    fullpathExecName = sys.argv[0]
    execName = os.path.split(fullpathExecName)[-1]
    execName = os.path.splitext(execName)[0]
    personalName = '/'.join([execName,sys.argv[1]])
    dataBase = PyTango.Database()
    result = dataBase.get_device_class_list(personalName)
    for i in range(len(result.value_string) / 2) :
        class_name = result.value_string[i * 2]
        deviceName = result.value_string[i * 2 + 1]
        className2deviceName[deviceName] = class_name
    return className2deviceName

class CallableReadEnum:
    def __init__(self,dictionnary,func2Call) :
        self.__dict = dictionnary
        self.__func2Call = func2Call

    def __call__(self,attr) :
        value = _getDictKey(self.__dict,self.__func2Call())
        attr.set_value(value)

class CallableWriteEnum:
    def __init__(self,attr_name,dictionnary,func2Call) :
        self.__attr_name = attr_name
        self.__dict = dictionnary
        self.__func2Call = func2Call
        
    def __call__(self,attr) :
        data = []
        attr.get_write_value(data)
        value = _getDictValue(self.__dict,data[0].upper())
        if value is None:
            PyTango.Except.throw_exception('WrongData',\
                                           'Wrong value %s: %s'%(self.__attr_name,data[0].upper()),\
                                           'LimaCCD Class')
        else:
            self.__func2Call(value)
        
#==================================================================
#
#    LimaCCDs class main method
#
#==================================================================
if __name__ == '__main__':
    try:
        py = PyTango.Util(sys.argv)
        py.add_TgClass(LimaCCDsClass,LimaCCDs,'LimaCCDs')
	try:
            declare_camera_n_commun_to_tango_world(py)
	except:
            print 'SEB_EXP'
            import traceback
            traceback.print_exc()
        
        U = PyTango.Util.instance()
        U.server_init()
	try:
            export_default_plugins()
	except:
            print 'SEB_EXP'
            import traceback
            traceback.print_exc()
        U.server_run()

    except PyTango.DevFailed,e:
        print '-------> Received a DevFailed exception:',e
    except Exception,e:
        print '-------> An unforeseen exception occured....',e
