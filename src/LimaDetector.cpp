static const char *RcsId = "$Id:  $";
//+=============================================================================
//
// file :         LimaDetector.cpp
//
// description :  C++ source for the LimaDetector and its commands. 
//                The class is derived from Device. It represents the
//                CORBA servant object which will be accessed from the
//                network. All commands which can be executed on the
//                LimaDetector are implemented in this file.
//
// project :      TANGO Device Server
//
// $Author:  $
//
// $Revision:  $
//
// $Revision:  $
// $Date:  $
//
// SVN only:
// $HeadURL: $
//
// CVS only:
// $Source:  $
// $Log:  $
//
// copyleft :    Synchrotron SOLEIL 
//               L'Orme des merisiers - Saint Aubin
//               BP48 - 91192 Gif sur Yvette
//               FRANCE
//
//-=============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================



//===================================================================
//
//	The following table gives the correspondence
//	between commands and method name.
//
//  Command name          |  Method name
//	----------------------------------------
//  State                 |  dev_state()
//  Status                |  dev_status()
//  DeleteRemainingFiles  |  delete_remaining_files()
//  Snap                  |  snap()
//  Start                 |  start()
//  Stop                  |  stop()
//  SetROI                |  set_roi()
//
//===================================================================


#include <tango.h>
#include <PogoHelper.h>
#include <LimaDetector.h>
#include <LimaDetectorClass.h>

#define MAX_ATTRIBUTE_STRING_LENGTH 	256

using namespace std;



namespace LimaDetector_ns
{



//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::LimaDetector(string &s)
// 
// description : 	constructor for simulated LimaDetector
//
// in : - cl : Pointer to the DeviceClass object
//      - s : Device name 
//
//-----------------------------------------------------------------------------
LimaDetector::LimaDetector(Tango::DeviceClass *cl,string &s)
:Tango::Device_4Impl(cl,s.c_str()),
m_dam(this)
{
	init_device();
}

LimaDetector::LimaDetector(Tango::DeviceClass *cl,const char *s)
:Tango::Device_4Impl(cl,s),
m_dam(this)
{
	init_device();
}

LimaDetector::LimaDetector(Tango::DeviceClass *cl,const char *s,const char *d)
:Tango::Device_4Impl(cl,s,d),
m_dam(this)
{
	init_device();
}
//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::delete_device()
// 
// description : 	will be called at device destruction or at init command.
//
//-----------------------------------------------------------------------------
void LimaDetector::delete_device()
{
	INFO_STREAM << "LimaDetector::LimaDetector() delete device " << device_name << endl;
	
	//	Delete device allocated objects
	DELETE_SCALAR_ATTRIBUTE(attr_exposureTime_read);
	DELETE_SCALAR_ATTRIBUTE(attr_exposureAccTime_read);
	DELETE_SCALAR_ATTRIBUTE(attr_sensorWidth_read);
	DELETE_SCALAR_ATTRIBUTE(attr_sensorHeight_read);
	DELETE_SCALAR_ATTRIBUTE(attr_depth_read);
	DELETE_SCALAR_ATTRIBUTE(attr_nbFrames_read);
	DELETE_SCALAR_ATTRIBUTE(attr_currentFrame_read);
	DELETE_SCALAR_ATTRIBUTE(attr_fileGeneration_read);
	DELETE_DEVSTRING_ATTRIBUTE(attr_detectorDescription_read);	
	DELETE_DEVSTRING_ATTRIBUTE(attr_detectorType_read);
	DELETE_DEVSTRING_ATTRIBUTE(attr_detectorModel_read);
	DELETE_DEVSTRING_ATTRIBUTE(attr_acquisitionMode_read);
	DELETE_DEVSTRING_ATTRIBUTE(attr_triggerMode_read);
	
	//remove attributes from dam
	m_dam.remove_attributes();
	
	// Delete control object via the factory
	if(m_ct!=0)
	{
		if(m_img_status_cb!=0)
		{
			m_ct->unregisterImageStatusCallback(*m_img_status_cb);
			m_img_status_cb = 0;
		}
		ControlFactory::instance().reset(detectorType);
		m_ct = 0;
		m_hw = 0;
	}
	
	// Exit acquisition task
	m_acquisition_task = NULL;

	//- remove the inner-appender
	yat4tango::InnerAppender::release(this);

}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::init_device()
// 
// description : 	will be called at device initialization.
//
//-----------------------------------------------------------------------------
void LimaDetector::init_device()
{
	INFO_STREAM << "LimaDetector::LimaDetector() create device " << device_name << endl;

	// Initialise variables to default values
	//--------------------------------------------
	
	// init some data members
	m_ct = 0;
	m_hw = 0;	
	m_is_device_initialized = false;
	m_status_message.str("");

	//- instanciate the appender in order ton manage logs
	try
	{
		//- specify both the associated device and the log buffer depth
		yat4tango::InnerAppender::initialize(this, 512);
	}
	catch( Tango::DevFailed& df )
	{
		ERROR_STREAM << df << endl;
		this->set_state(Tango::INIT);
		m_status_message <<"Initialization Failed :  could not instanciate the InnerAppender ! "<< endl;		
		return;
	}

	//By default INIT, need to ensure that all objets are OK before set the device to STANDBY
	set_state(Tango::INIT);

	get_device_property();
	
	CREATE_SCALAR_ATTRIBUTE(attr_exposureTime_read,1.0);
	CREATE_SCALAR_ATTRIBUTE(attr_exposureAccTime_read,1.0);	
	CREATE_SCALAR_ATTRIBUTE(attr_sensorWidth_read);
	CREATE_SCALAR_ATTRIBUTE(attr_sensorHeight_read);
	CREATE_SCALAR_ATTRIBUTE(attr_depth_read);
	CREATE_SCALAR_ATTRIBUTE(attr_nbFrames_read);
	CREATE_SCALAR_ATTRIBUTE(attr_currentFrame_read);
	CREATE_SCALAR_ATTRIBUTE(attr_fileGeneration_read);
	CREATE_DEVSTRING_ATTRIBUTE(attr_detectorDescription_read,MAX_ATTRIBUTE_STRING_LENGTH);
	CREATE_DEVSTRING_ATTRIBUTE(attr_detectorType_read,MAX_ATTRIBUTE_STRING_LENGTH);
	CREATE_DEVSTRING_ATTRIBUTE(attr_detectorModel_read,MAX_ATTRIBUTE_STRING_LENGTH);
	CREATE_DEVSTRING_ATTRIBUTE(attr_acquisitionMode_read,MAX_ATTRIBUTE_STRING_LENGTH);
	CREATE_DEVSTRING_ATTRIBUTE(attr_triggerMode_read,MAX_ATTRIBUTE_STRING_LENGTH);

	
	//----------------------------------------------------------------------------------
	//- Create lima control object and configure acquistion parameters
	try
	{
		////- Manage LIMA logs verbose
		DebParams::setModuleFlagsNameList(debugModules);
		DebParams::setTypeFlagsNameList(debugLevels);
	
		//- get the main object used to pilot the lima framework
		m_ct = ControlFactory::instance().get_control(detectorType, detectorIP);
		if(m_ct==0)
		{
			INFO_STREAM<<"Initialization Failed : Unable to create the lima control object !"<<endl;
			m_status_message <<"Initialization Failed : Unable to create the lima control object !"<< endl;
			m_is_device_initialized = false;
			set_state(Tango::INIT);		
			return;			
		}
		
		//- get interface to specific camera
		m_hw = dynamic_cast<HwInterface*>(m_ct->hwInterface());
		if(m_hw==0)
		{
			INFO_STREAM<<"Initialization Failed : Unable to get the interface of camera plugin !"<<endl;
			m_status_message <<"Initialization Failed : Unable to get the interface of camera plugin !"<< endl;
			m_is_device_initialized = false;
			set_state(Tango::INIT);		
			return;			
		}
		
		//- add image dynamic attribute
		//- fix curentImageType of detector (16 bits, 32 bits, ...)
		//- create image dyn attr (UChar, UShort or ULong)		
		//@@TODO Template this code later .
		HwDetInfoCtrlObj *hw_det_info;
		m_hw->getHwCtrlObj(hw_det_info);
		
		DynamicAttributeInfo dai;
		dai.dev = this;
		dai.tai.name = "image";
		dai.tai.data_format = Tango::IMAGE;
		
		switch(detectorPixelFormat)
		{
			case 8	: 	hw_det_info->setCurrImageType(Bpp8);
						dai.tai.data_type = Tango::DEV_UCHAR;
				break;			
			case 32	: 	hw_det_info->setCurrImageType(Bpp32);
						dai.tai.data_type = Tango::DEV_ULONG;
				break;
			default	: 	//by default 16 bits
						hw_det_info->setCurrImageType(Bpp16);
						dai.tai.data_type = Tango::DEV_USHORT;
				break;
		}
		dai.tai.writable = Tango::READ;
		dai.tai.disp_level = Tango::OPERATOR;
		dai.rcb = DynamicAttributeReadCallback::instanciate(*this, &LimaDetector::read_image_callback);
		//- add the attribute to the dam
		m_dam.add_attribute(dai);

		
		//- prepare a listen (callback) to receive some notifications from framework
		m_img_status_cb	= new ImageStatusCallback(*m_ct);
		m_ct->registerImageStatusCallback(*m_img_status_cb);
		
		//- parameters of acquisition
		m_ct->acquisition()->setAcqNbFrames(attr_nbFrames_write);

		//- parameters of ctSaving object used to store image in files
		m_saving_par.temporaryPath 	= fileTemporaryPath;
		m_saving_par.directory 		= fileTargetPath;
		m_saving_par.prefix 		= filePrefix;
		m_saving_par.indexFormat 	= fileIndexFormat;
		m_saving_par.nextNumber 	= 1;
		m_saving_par.savingMode 	= CtSaving::AutoFrame;
		m_saving_par.framesPerFile 	= fileNbFrames;
		m_saving_par.nbframes 		= attr_nbFrames_write;
		
		string strFileFormat(fileFormat);
		transform(strFileFormat.begin(), strFileFormat.end(),strFileFormat.begin(), ::toupper);
		
		if (strFileFormat.compare("NXS") == 0)
		{			
			m_saving_par.fileFormat = CtSaving::NXS;
			m_saving_par.suffix = ".nxs";
		}
		else if(strFileFormat.compare("EDF") == 0)
		{
			m_saving_par.fileFormat = CtSaving::EDF;
			m_saving_par.suffix = ".edf";
		}
		else if(strFileFormat.compare("CBF") == 0)
		{			
			m_saving_par.fileFormat = CtSaving::CBFFormat;
			m_saving_par.suffix = ".cbf";			
		}
		else
		{
			m_saving_par.fileFormat = CtSaving::RAW;
			m_saving_par.suffix = ".raw";		
		}

		m_ct->saving()->setParameters(m_saving_par);
	}
	catch(Exception& e)
	{
		INFO_STREAM<<"Initialization Failed : "<<e.getErrMsg()<<endl;
		m_status_message <<"Initialization Failed : "<<e.getErrMsg( )<< endl;
		m_is_device_initialized = false;
		set_state(Tango::INIT);		
		return;
	}
	catch(...)
	{
		INFO_STREAM<<"Initialization Failed : UNKNOWN"<<endl;
		m_status_message <<"Initialization Failed : UNKNOWN"<< endl;
		set_state(Tango::INIT);
		m_is_device_initialized = false;
		return;
	}
	
	//----------------------------------------------------------------------------------
	//- Create acqusisition Task, State = INIT if Task could not be created !
	if(create_acquisition_task() == false )
	{		
		set_state(Tango::INIT);
		m_is_device_initialized = false;
		return;
	}

	// everything seems ok
	m_is_device_initialized = true;
	set_state(Tango::STANDBY);
	this->dev_state();
}



//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::get_device_property()
// 
// description : 	Read the device properties from database.
//
//-----------------------------------------------------------------------------
void LimaDetector::get_device_property()
{
	//	Initialize your default values here (if not done with  POGO).
	//------------------------------------------------------------------

	//	Read device properties from database.(Automatic code generation)
	//------------------------------------------------------------------
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("DetectorDescription"));
	dev_prop.push_back(Tango::DbDatum("DetectorIP"));
	dev_prop.push_back(Tango::DbDatum("DetectorType"));
	dev_prop.push_back(Tango::DbDatum("DetectorPixelFormat"));
	dev_prop.push_back(Tango::DbDatum("FileFormat"));
	dev_prop.push_back(Tango::DbDatum("FilePrefix"));
	dev_prop.push_back(Tango::DbDatum("FileIndexFormat"));
	dev_prop.push_back(Tango::DbDatum("FileNbFrames"));
	dev_prop.push_back(Tango::DbDatum("FileTemporaryPath"));
	dev_prop.push_back(Tango::DbDatum("FileTargetPath"));
	dev_prop.push_back(Tango::DbDatum("DebugModules"));
	dev_prop.push_back(Tango::DbDatum("DebugLevels"));

	//	Call database and extract values
	//--------------------------------------------
	if (Tango::Util::instance()->_UseDb==true)
		get_db_device()->get_property(dev_prop);
	Tango::DbDatum	def_prop, cl_prop;
	LimaDetectorClass	*ds_class =
		(static_cast<LimaDetectorClass *>(get_device_class()));
	int	i = -1;

	//	Try to initialize DetectorDescription from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  detectorDescription;
	else {
		//	Try to initialize DetectorDescription from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  detectorDescription;
	}
	//	And try to extract DetectorDescription value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  detectorDescription;

	//	Try to initialize DetectorIP from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  detectorIP;
	else {
		//	Try to initialize DetectorIP from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  detectorIP;
	}
	//	And try to extract DetectorIP value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  detectorIP;

	//	Try to initialize DetectorType from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  detectorType;
	else {
		//	Try to initialize DetectorType from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  detectorType;
	}
	//	And try to extract DetectorType value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  detectorType;

	//	Try to initialize DetectorPixelFormat from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  detectorPixelFormat;
	else {
		//	Try to initialize DetectorPixelFormat from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  detectorPixelFormat;
	}
	//	And try to extract DetectorPixelFormat value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  detectorPixelFormat;

	//	Try to initialize FileFormat from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  fileFormat;
	else {
		//	Try to initialize FileFormat from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  fileFormat;
	}
	//	And try to extract FileFormat value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fileFormat;

	//	Try to initialize FilePrefix from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  filePrefix;
	else {
		//	Try to initialize FilePrefix from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  filePrefix;
	}
	//	And try to extract FilePrefix value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  filePrefix;

	//	Try to initialize FileIndexFormat from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  fileIndexFormat;
	else {
		//	Try to initialize FileIndexFormat from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  fileIndexFormat;
	}
	//	And try to extract FileIndexFormat value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fileIndexFormat;

	//	Try to initialize FileNbFrames from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  fileNbFrames;
	else {
		//	Try to initialize FileNbFrames from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  fileNbFrames;
	}
	//	And try to extract FileNbFrames value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fileNbFrames;

	//	Try to initialize FileTemporaryPath from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  fileTemporaryPath;
	else {
		//	Try to initialize FileTemporaryPath from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  fileTemporaryPath;
	}
	//	And try to extract FileTemporaryPath value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fileTemporaryPath;

	//	Try to initialize FileTargetPath from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  fileTargetPath;
	else {
		//	Try to initialize FileTargetPath from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  fileTargetPath;
	}
	//	And try to extract FileTargetPath value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  fileTargetPath;

	//	Try to initialize DebugModules from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  debugModules;
	else {
		//	Try to initialize DebugModules from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  debugModules;
	}
	//	And try to extract DebugModules value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  debugModules;

	//	Try to initialize DebugLevels from class property
	cl_prop = ds_class->get_class_property(dev_prop[++i].name);
	if (cl_prop.is_empty()==false)	cl_prop  >>  debugLevels;
	else {
		//	Try to initialize DebugLevels from default device value
		def_prop = ds_class->get_default_device_property(dev_prop[i].name);
		if (def_prop.is_empty()==false)	def_prop  >>  debugLevels;
	}
	//	And try to extract DebugLevels value from database
	if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  debugLevels;



	//	End of Automatic code generation
	//------------------------------------------------------------------
	vector<string> myVector;
	
	create_property_if_empty(dev_prop,"This is my simulator","DetectorDescription");	
	create_property_if_empty(dev_prop,"0.0.0.0","DetectorIP");	
	create_property_if_empty(dev_prop,"Simulator","DetectorType");
	create_property_if_empty(dev_prop,"16","DetectorPixelFormat");
	create_property_if_empty(dev_prop,"NXS","FileFormat");	
	create_property_if_empty(dev_prop,"Image","FilePrefix");
	create_property_if_empty(dev_prop,"%06d","FileIndexFormat");
	create_property_if_empty(dev_prop,"1","FileNbFrames");
	create_property_if_empty(dev_prop,".","FileTemporaryPath");	
	create_property_if_empty(dev_prop,"./data","FileTargetPath");
	
	myVector.clear();
	myVector.push_back("Hardware");
	myVector.push_back("Control");
	myVector.push_back("Common");
	myVector.push_back("Camera");
	create_property_if_empty(dev_prop,myVector,"DebugModules");
	
	myVector.clear();
	myVector.push_back("Fatal");
	myVector.push_back("Error");
	myVector.push_back("Warning");
	create_property_if_empty(dev_prop,myVector,"DebugLevels");		
}
//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::always_executed_hook()
// 
// description : 	method always executed before any command is executed
//
//-----------------------------------------------------------------------------
void LimaDetector::always_executed_hook()
{
	
}
//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_attr_hardware
// 
// description : 	Hardware acquisition for attributes.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_attr_hardware(vector<long> &attr_list)
{
	DEBUG_STREAM << "LimaDetector::read_attr_hardware(vector<long> &attr_list) entering... "<< endl;
	//	Add your own code here
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_detectorDescription
// 
// description : 	Extract real attribute values for detectorDescription acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_detectorDescription(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_detectorDescription(Tango::Attribute &attr) entering... "<< endl;
	try
	{
		strcpy(*attr_detectorDescription_read , detectorDescription.c_str());
		attr.set_value(attr_detectorDescription_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::read_detectorDescription"));	
	}
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_detectorType
// 
// description : 	Extract real attribute values for detectorType acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_detectorType(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_detectorType(Tango::Attribute &attr) entering... "<< endl;
	try
	{
		HwDetInfoCtrlObj *hw_det_info;
		m_hw->getHwCtrlObj(hw_det_info);

		string str_detector_type;
		hw_det_info->getDetectorType(str_detector_type);
	
		strcpy(*attr_detectorType_read , str_detector_type.c_str());
		attr.set_value(attr_detectorType_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::read_detectorType"));
	}	
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::read_detectorType"));		
	}			
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_detectorModel
// 
// description : 	Extract real attribute values for detectorModel acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_detectorModel(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_detectorModel(Tango::Attribute &attr) entering... "<< endl;

	try
	{
		HwDetInfoCtrlObj *hw_det_info;
		m_hw->getHwCtrlObj(hw_det_info);
	
		string str_detector_model;
		hw_det_info->getDetectorModel(str_detector_model);
		
		strcpy(*attr_detectorModel_read , str_detector_model.c_str());
		attr.set_value(attr_detectorModel_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::read_detectorModel"));
	}	
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::read_detectorModel"));		
	}		
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_sensorWidth
// 
// description : 	Extract real attribute values for sensorWidth acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_sensorWidth(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_sensorWidth(Tango::Attribute &attr) entering... "<< endl;
	try
	{
		HwDetInfoCtrlObj *hw_det_info;
		m_hw->getHwCtrlObj(hw_det_info);
		Size size;
		hw_det_info->getDetectorImageSize(size);
		
		*attr_sensorWidth_read = size.getWidth();
		attr.set_value(attr_sensorWidth_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::read_sensorWidth"));
	}	
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::read_sensorWidth"));		
	}		
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_sensorHeight
// 
// description : 	Extract real attribute values for sensorHeight acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_sensorHeight(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_sensorHeight(Tango::Attribute &attr) entering... "<< endl;
	try
	{
		HwDetInfoCtrlObj *hw_det_info;
		m_hw->getHwCtrlObj(hw_det_info);
		Size size;		
		hw_det_info->getDetectorImageSize(size);
		
		*attr_sensorHeight_read = size.getHeight();
		attr.set_value(attr_sensorHeight_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::read_sensorHeight"));
	}	
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::read_sensorHeight"));		
	}			
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_Depth
// 
// description : 	Extract real attribute values for Depth acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_depth(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_depth(Tango::Attribute &attr) entering... "<< endl;

	try
	{
		HwDetInfoCtrlObj *hw_det_info;
		m_hw->getHwCtrlObj(hw_det_info);
		ImageType image_type;
		hw_det_info->getCurrImageType(image_type);
		
		FrameDim frame_dim;
		*attr_depth_read = frame_dim.getImageTypeBpp(image_type);
		attr.set_value(attr_depth_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::read_depth"));
	}	
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::read_depth"));		
	}		
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_triggerMode
// 
// description : 	Extract real attribute values for triggerMode acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_triggerMode(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_triggerMode(Tango::Attribute &attr) entering... "<< endl;
	
	try
	{
		TrigMode trig_mode = IntTrig;
		m_ct->acquisition()->getTriggerMode(trig_mode);

		if (trig_mode == IntTrig)
			strcpy(*attr_triggerMode_read, "OFF");
		else if (trig_mode == ExtTrigSingle)
			strcpy(*attr_triggerMode_read, "TIMED");
		else //trig_mode == ExtGate:
			strcpy(*attr_triggerMode_read, "WIDTH");
			
		attr.set_value(attr_triggerMode_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
					static_cast<const char*> ("LimaDetector::read_triggerMode"));
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (e.getErrMsg().c_str()),
					static_cast<const char*> ("LimaDetector::read_triggerMode"));		
	}

}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::write_triggerMode
// 
// description : 	Write triggerMode attribute values to hardware.
//
//-----------------------------------------------------------------------------
void LimaDetector::write_triggerMode(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "LimaDetector::write_triggerMode(Tango::WAttribute &attr) entering... "<< endl;
	try
	{
		m_trigger_mode = *attr_triggerMode_read;
		string previous = m_trigger_mode;
		attr.get_write_value(attr_triggerMode_write);
		string current = attr_triggerMode_write;
		if(current.compare("OFF")!=0 && current.compare("TIMED")!=0 && current.compare("WIDTH")!=0)
		{
			m_trigger_mode = previous;			
			attr_triggerMode_write = new char [m_trigger_mode.size()+1];
			strcpy (attr_triggerMode_write, m_trigger_mode.c_str());
			
			Tango::Except::throw_exception(	(const char*) ("CONFIGURATION_ERROR"),
											(const char*) ("Available Trigger Modes are: \n- OFF \n- TIMED \n- WIDTH"),
											(const char*) ("LimaDetector::write_triggerMode"));
		}

		//- THIS IS AN AVAILABLE TRIGER MODE
		m_trigger_mode = attr_triggerMode_write;
	
		TrigMode trig_mode = IntTrig;
		if(m_trigger_mode.compare("OFF")==0)
			trig_mode = IntTrig;
		else if (m_trigger_mode.compare("TIMED")==0)
			trig_mode = ExtTrigSingle;
		else //m_trigger_mode.compare("WIDTH")==0
			trig_mode = ExtGate;
		
		m_ct->acquisition()->setTriggerMode(trig_mode);	
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
					static_cast<const char*> ("LimaDetector::write_triggerMode"));
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (e.getErrMsg().c_str()),
					static_cast<const char*> ("LimaDetector::write_triggerMode"));		
	}
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_acquisitionMode
// 
// description : 	Extract real attribute values for acquisitionMode acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_acquisitionMode(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_acquisitionMode(Tango::Attribute &attr) entering... "<< endl;
	
	try
	{
		AcqMode acq_mode = Single;
		m_ct->acquisition()->getAcqMode(acq_mode);
		if (acq_mode == Single)
			strcpy(*attr_acquisitionMode_read, "SINGLE");
		else //acq_mode == Accumulation
			strcpy(*attr_acquisitionMode_read, "ACCUMULATION");	
		attr.set_value(attr_acquisitionMode_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::read_acquisitionMode"));	
	}
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::write_acquisitionMode
// 
// description : 	Write acquisitionMode attribute values to hardware.
//
//-----------------------------------------------------------------------------
void LimaDetector::write_acquisitionMode(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "LimaDetector::write_acquisitionMode(Tango::WAttribute &attr) entering... "<< endl;
	
	try
	{
		string previous = m_acquisition_mode;
		attr.get_write_value(attr_acquisitionMode_write);
		string current = attr_acquisitionMode_write;
		if(current.compare("SINGLE")!=0 && current.compare("ACCUMULATION")!=0)
		{
			m_acquisition_mode = previous;			
			attr_acquisitionMode_write = new char [m_acquisition_mode.size()+1];
			strcpy (attr_acquisitionMode_write, m_acquisition_mode.c_str());

			Tango::Except::throw_exception(	(const char*) ("CONFIGURATION_ERROR"),
											(const char*) ("Available Acquisition Modes are: \n- SINGLE \n- ACCUMULATION"),
											(const char*) ("LimaDetector::write_acquisitionMode"));
		}
		
		//- THIS IS AN AVAILABLE ACQUISITION MODE
		m_acquisition_mode = attr_acquisitionMode_write;
		
		if(m_acquisition_mode.compare("SINGLE")==0)
			m_ct->acquisition()->setAcqMode(Single);
			
		if(m_acquisition_mode.compare("ACCUMULATION")==0)
			m_ct->acquisition()->setAcqMode(Accumulation);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::write_acquisitionMode"));
	}	
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::write_acquisitionMode"));		
	}		
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_exposureTime
// 
// description : 	Extract real attribute values for exposureTime acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_exposureTime(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_exposureTime(Tango::Attribute &attr) entering... "<< endl;
	try
	{
		double exposure;
		m_ct->acquisition()->getAcqExpoTime(exposure);
		*attr_exposureTime_read = (Tango::DevDouble)(exposure*1000.0);//exposure USER OUTPUT is in millisec
		attr.set_value(attr_exposureTime_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::read_exposureTime"));
	}	
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::read_exposureTime"));		
	}		
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::write_exposureTime
// 
// description : 	Write exposureTime attribute values to hardware.
//
//-----------------------------------------------------------------------------
void LimaDetector::write_exposureTime(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "LimaDetector::write_exposureTime(Tango::WAttribute &attr) entering... "<< endl;
	try
	{
		attr.get_write_value(attr_exposureTime_write);
		m_ct->acquisition()->setAcqExpoTime((double)(attr_exposureTime_write/1000.0));//exposure USER INPUT is in millisec	
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::write_exposureTime"));
	}	
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::write_exposureTime"));		
	}		
}


//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_exposureAccTime
// 
// description : 	Extract real attribute values for exposureAccTime acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_exposureAccTime(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_exposureAccTime(Tango::Attribute &attr) entering... "<< endl;
	try
	{
		if(m_acquisition_mode.compare("ACCUMULATION")==0)
		{
			double exposure;
			m_ct->acquisition()->getAccExpoTime(exposure);
			*attr_exposureAccTime_read = (Tango::DevDouble)(exposure*1000.0);
			attr.set_value(attr_exposureAccTime_read);
		}
		else
		{
			attr.set_quality(Tango::ATTR_INVALID);			
		}
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::read_exposureAccTime"));
	}	
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::read_exposureAccTime"));		
	}	
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::write_exposureAccTime
// 
// description : 	Write exposureAccTime attribute values to hardware.
//
//-----------------------------------------------------------------------------
void LimaDetector::write_exposureAccTime(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "LimaDetector::write_exposureAccTime(Tango::WAttribute &attr) entering... "<< endl;
	try
	{
		attr.get_write_value(attr_exposureAccTime_write);
		m_ct->acquisition()->setAccMaxExpoTime((double)(attr_exposureAccTime_write/1000.0));
	
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::write_exposureAccTime"));
	}	
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::write_exposureAccTime"));		
	}	
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_nbFrames
// 
// description : 	Extract real attribute values for nbFrames acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_nbFrames(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_nbFrames(Tango::Attribute &attr) entering... "<< endl;
	int nbframes = 0;
	try
	{
		m_ct->acquisition()->getAcqNbFrames(nbframes);
		*attr_nbFrames_read = nbframes;
		attr.set_value(attr_nbFrames_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::read_nbFrames"));
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::read_nbFrames"));		
	}	
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::write_nbFrames
// 
// description : 	Write nbFrames attribute values to hardware.
//
//-----------------------------------------------------------------------------
void LimaDetector::write_nbFrames(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "LimaDetector::write_nbFrames(Tango::WAttribute &attr) entering... "<< endl;
	try
	{
		attr.get_write_value(attr_nbFrames_write);
		m_ct->acquisition()->setAcqNbFrames(attr_nbFrames_write);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::write_nbFrames"));
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::write_nbFrames"));		
	}		
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_currentFrame
// 
// description : 	Extract real attribute values for currentFrame acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_currentFrame(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_currentFrame(Tango::Attribute &attr) entering... "<< endl;
	try
	{
		*attr_currentFrame_read = m_img_status_cb->get_image_number();
		attr.set_value(attr_currentFrame_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::read_currentFrame"));
	}	
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::read_currentFrame"));		
	}		
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_image_callback()
// 
// description : 	
//
//-----------------------------------------------------------------------------
void LimaDetector::read_image_callback(yat4tango::DynamicAttributeReadCallbackData& cbd)
{
	DEBUG_STREAM << "LimaDetector::read_image_callback()"<<endl;//  << cbd.dya->get_name() << endl;
	try
	{
		//@@TODO Template this code later .
		if((m_img_status_cb->get_last_image()->data())!=0 )
		{
			switch (cbd.dya->get_tango_data_type())
			{
				case  TangoTraits<Tango::DevUChar>::type_id : 	cbd.tga->set_value((Tango::DevUChar*)m_img_status_cb->get_last_image()->data(),
																					m_img_status_cb->get_last_image()->width,
																					m_img_status_cb->get_last_image()->height);
				break;
				case  TangoTraits<Tango::DevULong>::type_id : 	cbd.tga->set_value( (Tango::DevULong*)m_img_status_cb->get_last_image()->data(),
																					m_img_status_cb->get_last_image()->width,
																					m_img_status_cb->get_last_image()->height);
				break;
				//by default 16 bits
				default	:										cbd.tga->set_value( (Tango::DevUShort*)m_img_status_cb->get_last_image()->data(),
																					m_img_status_cb->get_last_image()->width,
																					m_img_status_cb->get_last_image()->height);
				break;
			}
		}
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
				static_cast<const char*> ("TANGO_DEVICE_ERROR"),
				static_cast<const char*> (string(df.errors[0].desc).c_str()),
				static_cast<const char*> ("LimaDetector::read_image_callback"));
	}	
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
		//- throw exception
		Tango::Except::throw_exception(
			static_cast<const char*> ("TANGO_DEVICE_ERROR"),
			static_cast<const char*> (e.getErrMsg().c_str()),
			static_cast<const char*> ("LimaDetector::read_image_callback"));		
	}				
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::read_fileGeneration
// 
// description : 	Extract real attribute values for fileGeneration acquisition result.
//
//-----------------------------------------------------------------------------
void LimaDetector::read_fileGeneration(Tango::Attribute &attr)
{
	DEBUG_STREAM << "LimaDetector::read_fileGeneration(Tango::Attribute &attr) entering... "<< endl;
	try
	{
		CtSaving::SavingMode mode;
		m_ct->saving()->getSavingMode(mode);
		if(mode == CtSaving::AutoFrame)
			*attr_fileGeneration_read = true;
		else
			*attr_fileGeneration_read = false;
			
		attr.set_value(attr_fileGeneration_read);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::read_fileGeneration"));
	}	
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::write_fileGeneration
// 
// description : 	Write fileGeneration attribute values to hardware.
//
//-----------------------------------------------------------------------------
void LimaDetector::write_fileGeneration(Tango::WAttribute &attr)
{
	DEBUG_STREAM << "LimaDetector::write_fileGeneration(Tango::WAttribute &attr) entering... "<< endl;
	try
	{
		attr.get_write_value(attr_fileGeneration_write);
		if(attr_fileGeneration_write == true)
			m_ct->saving()->setSavingMode(CtSaving::AutoFrame);
		else
			m_ct->saving()->setSavingMode(CtSaving::Manual);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::write_fileGeneration"));
	}			
}


//+------------------------------------------------------------------
/**
 *	method:	LimaDetector::delete_remaining_files
 *
 *	description:	method to execute "DeleteRemainingFiles"
 *	Remove all EDF files in the directory defined by the property TemporaryEDFFilePath
 *
 *
 */
//+------------------------------------------------------------------
void LimaDetector::delete_remaining_files()
{
	DEBUG_STREAM << "LimaDetector::delete_remaining_files(): entering... !" << endl;

	//	Add your own code to control device here

	try
	{	
		yat::Message* msg = yat::Message::allocate( DEVICE_DELETE_FILES_MSG, DEFAULT_MSG_PRIORITY, true );
		m_acquisition_task->post(msg);
		//restart at index 1
		if(m_ct->saving())
			m_ct->saving()->setNextNumber(1);		
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::delete_remaining_files"));
	}	
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::delete_remaining_files"));		
	}			
}

//+------------------------------------------------------------------
/**
 *	method:	LimaDetector::snap
 *
 *	description:	method to execute "Snap"
 *
 *
 */
//+------------------------------------------------------------------
void LimaDetector::snap()
{
	DEBUG_STREAM << "LimaDetector::snap(): entering... !" << endl;

	//	Add your own code to control device here
	try
	{
		if(attr_nbFrames_write == 0)
		{
			//- throw exception
			Tango::Except::throw_exception(	(const char*) ("CONFIGURATION_ERROR"),
											(const char*) ("Snap command is not Available when 'nbFrames' is 0\nUse Start command to diplay a 'video' stream.\n"),
											(const char*) ("LimaDetector::snap"));
		}
			
		m_saving_par.nbframes 		= attr_nbFrames_write;		
		if(attr_fileGeneration_write)
		{
			m_ct->saving()->setSavingMode(CtSaving::AutoFrame);
			m_ct->saving()->setParameters(m_saving_par);			
		}
		else
		{
			m_ct->saving()->setSavingMode(CtSaving::Manual);		
		}
		
		//- in SNAP mode, we request attr_nbFrames_write frames
		m_ct->acquisition()->setAcqNbFrames(attr_nbFrames_write);

		m_img_status_cb->reset_image_number();
		
		//- print some infos
		print_acq_conf();
		
		yat::Message* msg = yat::Message::allocate( DEVICE_SNAP_MSG, DEFAULT_MSG_PRIORITY, true );
		m_acquisition_task->wait_msg_handled(msg, 5000);//to ensure that state was updated in lima
		

	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::snap"));
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::snap"));		
	}			
}

//+------------------------------------------------------------------
/**
 *	method:	LimaDetector::start
 *
 *	description:	method to execute "Start"
 *
 *
 */
//+------------------------------------------------------------------
void LimaDetector::start()
{
	DEBUG_STREAM << "LimaDetector::start(): entering... !" << endl;

	//	Add your own code to control device here
	try
	{
        if(attr_fileGeneration_write == true)
		{
			//- throw exception
			Tango::Except::throw_exception(	(const char*) ("CONFIGURATION_ERROR"),
											(const char*) ("Start command is not Available when 'fileGeneration' is enabled\n"),
											(const char*) ("LimaDetector::start"));
		}
		
		m_saving_par.nbframes 		= 0;
		
		//- force NO saving files in continuous mode !
		m_ct->saving()->setSavingMode(CtSaving::Manual);
		
		//- in START "LIVE" mode, we request (0) as frames number
		m_ct->acquisition()->setAcqNbFrames(0);

		m_img_status_cb->reset_image_number();
		
		//- print some infos
		print_acq_conf();

		yat::Message* msg = yat::Message::allocate( DEVICE_START_MSG, DEFAULT_MSG_PRIORITY, true );
		m_acquisition_task->wait_msg_handled(msg, 5000);//to ensure that state was updated in lima
	
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::start"));
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::start"));		
	}	
}

//+------------------------------------------------------------------
/**
 *	method:	LimaDetector::stop
 *
 *	description:	method to execute "Stop"
 *
 *
 */
//+------------------------------------------------------------------
void LimaDetector::stop()
{
	DEBUG_STREAM << "LimaDetector::stop(): entering... !" << endl;

	//	Add your own code to control device here
	try
	{		
		yat::Message* msg = yat::Message::allocate( DEVICE_STOP_MSG, DEFAULT_MSG_PRIORITY, true );
		m_acquisition_task->wait_msg_handled(msg, 5000);//to ensure that state was updated in lima
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::stop"));
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::stop"));		
	}
}

//+------------------------------------------------------------------
/**
 *	method:	LimaDetector::set_roi
 *
 *	description:	method to execute "SetROI"
 *
 * @param	argin	[origin_x, origin_y, width, height]
 *
 */
//+------------------------------------------------------------------
void LimaDetector::set_roi(const Tango::DevVarLongArray *argin)
{
	DEBUG_STREAM << "LimaDetector::set_roi(): entering... !" << endl;

	//	Add your own code to control device here
	try
	{
		unsigned long x      = (*argin)[0];
		unsigned long y      = (*argin)[1];
		unsigned long width  = (*argin)[2];
		unsigned long height = (*argin)[3];
		
		//- set the new ROI
		Roi roi(Point(x, y), Size(width,height));
		m_ct->image()->resetRoi();
		m_ct->image()->setRoi(roi);
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM << df << endl;
        //- rethrow exception
        Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
                    static_cast<const char*> ("LimaDetector::set_roi"));
	}
	catch(Exception& e)
	{
		ERROR_STREAM << e.getErrMsg() << endl;
        //- throw exception
        Tango::Except::throw_exception(
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (e.getErrMsg().c_str()),
                    static_cast<const char*> ("LimaDetector::set_roi"));		
	}

}
//+------------------------------------------------------------------
/**
 *	method:	LimaDetector::dev_state
 *
 *	description:	method to execute "State"
 *	This command gets the device state (stored in its <i>device_state</i> data member) and returns it to the caller.
 *
 * @return	State Code
 *
 */
//+------------------------------------------------------------------
Tango::DevState LimaDetector::dev_state()
{
	Tango::DevState	argout = DeviceImpl::dev_state();
	DEBUG_STREAM << "LimaDetector::dev_state(): entering... !" << endl;

	//	Add your own code to control device here
	stringstream    DeviceStatus;
	DeviceStatus 	<< "";
	Tango::DevState DeviceState	= Tango::STANDBY;
	//if error during init_device
	if(!m_is_device_initialized)
	{
		DeviceState		= Tango::INIT;
		DeviceStatus	<< m_status_message.str();
		DeviceStatus	<< endl;
	}
	else
	{
		// if error in acquisition task
		if(m_acquisition_task->get_state()==Tango::FAULT)
		{
			DeviceState=Tango::FAULT;//FAULT
			DeviceStatus<<m_acquisition_task->get_status()<<endl;			
		}
		else
		{
			CtControl::Status status;
			m_ct->getStatus(status);
			if (status.AcquisitionStatus == lima::AcqReady)
			{
				DeviceState=Tango::STANDBY;
				DeviceStatus<<"Waiting for Request ...\n"<<endl;
			}		
			else if(status.AcquisitionStatus == lima::AcqRunning)
			{
				DeviceState=Tango::RUNNING;
				DeviceStatus<<"Acquisition is Running ...\n"<<endl;
			}
			else
			{
				DeviceState=Tango::FAULT;//FAULT
				DeviceStatus<<"Acquisition is in Fault\n"<<endl;
			}
		}
	}
	
	set_state(DeviceState);
	set_status(DeviceStatus.str());
	
	argout = DeviceState;
	return argout;
}

//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::create_acquisition_task
// 
//-----------------------------------------------------------------------------
bool LimaDetector::create_acquisition_task(void)
{
	DEBUG_STREAM << "LimaDetector::CreateAcquisitionTask()" << endl;		
	//- Prepare Acquisition task
	try
	{	
		//---------------------------------------------------------------------
		//- Create the task
		m_acquisition_task = new AcquisitionTask(this);
		
		//- prepare the conf to be passed to the task
		m_acq_conf.ct				= m_ct;
		m_acq_conf.file_target_path	= fileTargetPath;		//property, no need to refresh on each START_MSG

		//- create an INIT msg to pass it some data (Conf)
		yat::Message* msg = yat::Message::allocate( yat::TASK_INIT, INIT_MSG_PRIORITY, true );
		msg->attach_data( m_acq_conf );
		m_acquisition_task->go( msg ); //- post the INIT msg
	}
	catch( yat::Exception& ex )
	{
		//throw_devfailed( ex );
		m_status_message <<"Initialization Failed : "<<endl;		
		for(unsigned i = 0; i < ex.errors.size(); i++)
		{
			m_status_message <<ex.errors[i].desc<<endl;
		}			
		ex.dump();	
		return false;
	}
	catch(Tango::DevFailed& df)
	{
		ERROR_STREAM<<df<<endl;
		m_status_message << "Initialization Failed : "<<endl;
		for(unsigned i = 0; i < df.errors.length(); i++)
		{
			m_status_message << df.errors[i].desc<<endl;
		}		
		return false;
	}
	catch(...)
	{
		ERROR_STREAM <<"Initialization Failed : UNKNOWN"<<endl;
		m_status_message <<"Initialization Failed : UNKNOWN"<<endl;
		return false;
	}

	//---------------------------------------------------------------------
	//everything seems OK
	return true;
}



//+----------------------------------------------------------------------------
//
// method : 		LimaDetector::print_acq_conf
// 
//-----------------------------------------------------------------------------
void LimaDetector::print_acq_conf(void)
{
	INFO_STREAM<<"-----------------------------------------------"<<endl;
	
	
	INFO_STREAM<<"PixelFormat\t\t = "		<<detectorPixelFormat<<endl;
	INFO_STREAM<<"triggerMode\t\t = "		<<m_trigger_mode<<endl;
	INFO_STREAM<<"acquisitionMode\t\t = "	<<m_acquisition_mode<<endl;
	INFO_STREAM<<"exposureTime\t\t = "		<<*attr_exposureTime_read<<endl;
	INFO_STREAM<<"exposureAccTime\t = "		<<*attr_exposureAccTime_read<<endl;
	INFO_STREAM<<"temporaryPath\t\t = "		<<m_saving_par.temporaryPath<<endl;
	INFO_STREAM<<"directory\t\t = "			<<m_saving_par.directory<<endl;
	INFO_STREAM<<"prefix\t\t = "			<<m_saving_par.prefix<<endl;
	INFO_STREAM<<"suffix\t\t = "			<<m_saving_par.suffix<<endl;
	INFO_STREAM<<"indexFormat\t\t = "		<<m_saving_par.indexFormat<<endl;
	INFO_STREAM<<"framesPerFile\t\t = "		<<m_saving_par.framesPerFile<<endl;
	INFO_STREAM<<"nbframes\t\t = "			<<m_saving_par.nbframes<<endl;
	INFO_STREAM<<"fileGeneration\t\t = "	<<attr_fileGeneration_write<<endl;	
	Roi roi;
	HwRoiCtrlObj *hw_roi;
	m_hw->getHwCtrlObj(hw_roi);
	if(hw_roi)
	{
		hw_roi->getRoi(roi);
		INFO_STREAM<<"Roi\t\t = ["	<<roi.getTopLeft().x		<<" , "
									<<roi.getTopLeft().y		<<" , "
									<<roi.getSize().getWidth()	<<" , "
									<<roi.getSize().getHeight()	<<
								"]"
					<<endl;
	}
	
	INFO_STREAM<<"-----------------------------------------------"<<endl;	
}

/*-------------------------------------------------------------------------
//       LimaDetector::store_value_as_property
/-------------------------------------------------------------------------*/
template <class T>
void LimaDetector::store_value_as_property (T value, string property_name)
{
	Tango::DbDatum current_value(property_name);
	current_value << value;
	Tango::DbData db_data;
	db_data.push_back(current_value);
	try
	{
		get_db_device()->put_property(db_data);
	}
	catch(Tango::DevFailed &df)
	{
		string message= "Error in storing " + property_name + " in Configuration DataBase ";
		LOG_ERROR((message));
		ERROR_STREAM<<df<<endl;
		//- rethrow exception
		Tango::Except::re_throw_exception(df,
					static_cast<const char*> ("TANGO_DEVICE_ERROR"),
					static_cast<const char*> (string(df.errors[0].desc).c_str()),
					static_cast<const char*> ("LimaDetector::store_value_as_property"));				
	}

}

/*-------------------------------------------------------------------------
//       LimaDetector::create_property_if_empty
/-------------------------------------------------------------------------*/
template <class T>
void LimaDetector::create_property_if_empty(Tango::DbData& dev_prop,T value,string property_name)
{
	int iPropertyIndex = FindIndexFromPropertyName(dev_prop,property_name);
	if (iPropertyIndex == -1) return;
	if (dev_prop[iPropertyIndex].is_empty())
	{
		Tango::DbDatum current_value(dev_prop[iPropertyIndex].name);
		current_value << value;
		Tango::DbData db_data;
		db_data.push_back(current_value);
		
		try
		{
			get_db_device()->put_property(db_data);
		}
		catch(Tango::DevFailed &df)
		{
			string message= "Error in storing " + property_name + " in Configuration DataBase ";
			LOG_ERROR((message));
			ERROR_STREAM<<df<<endl;
			//- rethrow exception
			Tango::Except::re_throw_exception(df,
						static_cast<const char*> ("TANGO_DEVICE_ERROR"),
						static_cast<const char*> (string(df.errors[0].desc).c_str()),
						static_cast<const char*> ("LimaDetector::create_property_if_empty"));			
		}
	}
}


/*-------------------------------------------------------------------------
//       LimaDetector::FindIndexFromPropertyName
/-------------------------------------------------------------------------*/
int LimaDetector::FindIndexFromPropertyName(Tango::DbData& dev_prop, string property_name)
{
	size_t iNbProperties = dev_prop.size();
	unsigned int i;
	for (i=0;i<iNbProperties;i++)
	{
		string sPropertyName(dev_prop[i].name);
		if (sPropertyName == property_name) return i;
	}
	if (i == iNbProperties) return -1;
	return i;
}




}	//	namespace
